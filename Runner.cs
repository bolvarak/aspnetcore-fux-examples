using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace Fux.Example
{
    /// <summary>
    /// This class maintains the structure of a runner
    /// </summary>
    public abstract class Runner
    {
        /// <summary>
        /// This delegate defines the structure of FAF task
        /// </summary>
        /// <param name="id"></param>
        /// <param name="ticker"></param>
        /// <returns></returns>
        public delegate Task DelegateFireAndForgetTask(string id, Core.Ticker ticker);

        /// <summary>
        /// This delegates defines the structure of a FAF task with a typed ID
        /// </summary>
        /// <typeparam name="TIdentifier"></typeparam>
        /// <param name="id"></param>
        /// <param name="ticker"></param>
        /// <returns></returns>
        public delegate Task DelegateFireAndForgetTask<TIdentifier>(TIdentifier id, Core.Ticker ticker);

        /// <summary>
        /// This property contains the tasks that were run in Fire-And-Forget mode
        /// </summary>
        private readonly Dictionary<string, dynamic> _fafMap =
            new Dictionary<string, dynamic>();

        /// <summary>
        /// This property contains our logger
        /// </summary>
        private ILogger<Runner> _logger = null;

        /// <summary>
        /// This property contains a list of messages that were generated by the runner
        /// </summary>
        private readonly List<Helper.Message> _messageList =
            new List<Helper.Message>();

        /// <summary>
        /// This method provides a static factory for instantiating and executing runners
        /// </summary>
        /// <typeparam name="TRunner"></typeparam>
        public static void Execute<TRunner>() where TRunner : Runner, new() =>
            Core.Reflection.Instance<TRunner>().Run();

        /// <summary>
        /// This method provides a static factory for instantiating and executing asynchronous runners
        /// </summary>
        /// <typeparam name="TRunner"></typeparam>
        /// <returns></returns>
        public static Task ExecuteAsync<TRunner>() where TRunner : Runner, new() =>
            Core.Reflection.Instance<TRunner>().RunAsync();

        /// <summary>
        /// This method instantiates the runner with a logger
        /// </summary>
        /// <param name="logger"></param>
        public Runner(ILogger<Runner> logger = null)
        {
            // Set the logger into the instance
            _logger = logger;
        }

        /// <summary>
        /// This method adds and runs a completely anonymous FAF task
        /// </summary>
        /// <param name="task"></param>
        /// <returns></returns>
        protected Guid FireAndForget(DelegateFireAndForgetTask<Guid> task) =>
            FireAndForget<Guid>(Guid.NewGuid(), task);

        /// <summary>
        /// This method adds and runs FAF task with an external ID
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="task"></param>
        /// <returns></returns>
        protected Guid FireAndForget(Guid taskId, DelegateFireAndForgetTask<Guid> task) =>
            FireAndForget<Guid>(taskId, task);

        /// <summary>
        /// This method adds and runs a FAF task with a custom external ID
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="task"></param>
        /// <returns></returns>
        protected string FireAndForget(string taskId, DelegateFireAndForgetTask task)
        {
            // Define our ticker
            Core.Ticker ticker = new Core.Ticker();
            // Start the ticker
            ticker.Reset();
            // Add the FAF task to the instance
            _fafMap[taskId] = task
                .Invoke(taskId, ticker)
                .ContinueWith((asyncTask) =>
                {
                    // Stop our ticker and localize the time table
                    Core.TickerTimeTable tickerTimeTable = ticker.Halt();
                    // Define our parts
                    List<string> parts = new List<string>();
                    // Define our prefix
                    parts.Add($"[Internal: {asyncTask.Id} Fux: {taskId}] Task");
                    // Check the cancelled flag
                    if (asyncTask.IsCanceled) parts.Add("was Cancelled in ${taskElapsed}");
                    // Check the completed successfully flag
                    if (asyncTask.IsCompletedSuccessfully) parts.Add("Completed Successfully in ${taskElapsed}");
                    // Check the faulted flag
                    if (asyncTask.IsFaulted) parts.Add("Faulted in ${taskElapsed} [Error: ${exceptionMessage}]");
                    // Check the completed flag
                    if (asyncTask.IsCompleted) parts.Add("Completed in ${taskElapsed}");
                    // Log the message
                    LogMessage(
                        Helper.Message.New(string.Join(' ', parts))
                            .WithDataObject("taskElapsed", tickerTimeTable.Elapsed)
                            .WithDataObject("exceptionMessage", asyncTask.Exception?.Message));
                    // Dispose of the task
                    asyncTask.Dispose();
                });
            // Return the unique ID of the FAF task
            return taskId;
        }

        /// <summary>
        /// This method adds and runs a FAF task with a custom external ID
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="task"></param>
        /// <returns></returns>
        protected TIdentifier FireAndForget<TIdentifier>(TIdentifier taskId, DelegateFireAndForgetTask<TIdentifier> task)
        {
            // Define our ticker
            Core.Ticker ticker = new Core.Ticker();
            // Start the ticker
            ticker.Reset();
            // Add the FAF task to the instance
            _fafMap[Core.Convert.ToString<TIdentifier>(taskId)] = task
                .Invoke(taskId, ticker)
                .ContinueWith((asyncTask) =>
                {
                    // Stop our ticker and localize the time table
                    Core.TickerTimeTable tickerTimeTable = ticker.Halt();
                    // Define our parts
                    List<string> parts = new List<string>();
                    // Define our prefix
                    parts.Add($"[Internal: {asyncTask.Id} Fux: {taskId}] Task");
                    // Check the cancelled flag
                    if (asyncTask.IsCanceled) parts.Add("was Cancelled in ${taskElapsed}");
                    // Check the completed successfully flag
                    if (asyncTask.IsCompletedSuccessfully) parts.Add("Completed Successfully in ${taskElapsed}");
                    // Check the faulted flag
                    if (asyncTask.IsFaulted) parts.Add("Faulted in ${taskElapsed} [Error: ${exceptionMessage}]");
                    // Check the completed flag
                    if (asyncTask.IsCompleted) parts.Add("Completed in ${taskElapsed}");
                    // Log the message
                    LogMessage(
                        Helper.Message.New(string.Join(' ', parts))
                            .WithDataObject("taskElapsed", tickerTimeTable.Elapsed)
                            .WithDataObject("exceptionMessage", asyncTask.Exception?.Message));
                    // Dispose of the task
                    asyncTask.Dispose();
                });
            // We're done, return the unique ID of the task
            return taskId;
        }

        /// <summary>
        /// This method is responsible for the specific action of the runner
        /// </summary>
        /// <param name="ticker"></param>
        /// <returns></returns>
        protected virtual void Task(Core.Ticker ticker) => throw new NotImplementedException();

        /// <summary>
        /// This method is responsible for the specific asynchronous action of the runner
        /// </summary>
        /// <param name="ticker"></param>
        /// <returns></returns>
        protected virtual Task TaskAsync(Core.Ticker ticker) => throw new NotImplementedException();

        /// <summary>
        /// This method logs a message when the task is done
        /// </summary>
        /// <param name="ticker"></param>
        protected void WhenTaskDone(Core.Ticker ticker) =>
            LogMessage(Helper.Message.New("Task Completed In ${tickerElapsed}")
                .WithDataObject("tickerElapsed", ticker.Halt().Elapsed));

        /// <summary>
        /// This method returns a message from the instance if it exists
        /// </summary>
        /// <param name="messageId"></param>
        /// <returns></returns>
        public Helper.Message Message(Guid messageId) =>
            _messageList.Where(m => m.Id.Equals(messageId)).FirstOrDefault();

        /// <summary>
        /// This method executes the runner
        /// </summary>
        public void Run()
        {
            // Define our ticker
            Core.Ticker ticker = new Core.Ticker();
            // Execte the task
            Task(ticker);
            // Execute the completion callback
            WhenTaskDone(ticker);
        }

        /// <summary>
        /// This method asynchronously executes the runner
        /// </summary>
        /// <returns></returns>
        public async Task RunAsync()
        {
            // Define our ticker
            Core.Ticker ticker = new Core.Ticker();
            // Execute the task
            await TaskAsync(ticker);
            // Execute the completion callback
            WhenTaskDone(ticker);
        }

        /// <summary>
        /// This method logs an external message construct
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        public Runner LogMessage(Helper.Message message)
        {
            // Check for a message
            if (message != null)
            {
                // Write the message to the console console
                Console.WriteLine($"\n{message.ToString()}");
                // Reset the sent timestamp on the message
                message.Sent = DateTime.UtcNow;
            }
            // We're done, return the instance
            return this;
        }

        /// <summary>
        /// This method logs a message by its unique ID
        /// </summary>
        /// <param name="messageId"></param>
        /// <returns></returns>
        public Runner LogMessage(Guid messageId) =>
            LogMessage(_messageList.FirstOrDefault(m => m.Id.Equals(messageId)));

        /// <summary>
        /// This method generates and logs a message
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Runner LogMessage(string message, IDictionary<string, dynamic> dataObjects = null) =>
            LogMessage(WithMessage(message, dataObjects));

        /// <summary>
        /// This method generates and logs a message
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Runner LogMessage(string message, params dynamic[] dataObjects) =>
            LogMessage(WithPriorityMessage(message, dataObjects));


        public Runner LogPriorityMessage(Helper.Message message) =>
            LogMessage(message.WithPriority());

        /// <summary>
        /// This method generates and logs a priority message
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Runner LogPriorityMessage(string message, IDictionary<string, dynamic> dataObjects = null) =>
            LogMessage(WithPriorityMessage(message, dataObjects));

        /// <summary>
        /// This method generates and logs a priority message
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Runner LogPriorityMessage(string message, params dynamic[] dataObjects) =>
            LogMessage(WithPriorityMessage(message, dataObjects));

        /// <summary>
        /// This method adds an externally generated message to the instance
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        public Guid WithMessage(Helper.Message message)
        {
            // Instantiate the message and add it to the list
            _messageList.Add(message);
            // We're done, return the unique ID of the message
            return message.Id;
        }

        /// <summary>
        /// This method adds a message to the instance
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Guid WithMessage(string message, IDictionary<string, dynamic> dataObjects = null) =>
            WithMessage(Helper.Message.New(message, dataObjects ?? new Dictionary<string, dynamic>()));

        /// <summary>
        /// This method adds a message to the instance
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Guid WithMessage(string message, params dynamic[] dataObjects) =>
            WithMessage(message, dataObjects);

        /// <summary>
        /// This method adds a priority message to the instance
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Guid WithPriorityMessage(string message, IDictionary<string, dynamic> dataObjects = null) =>
            WithMessage(Helper.Message.New(message, dataObjects ?? new Dictionary<string, dynamic>(), true));

        /// <summary>
        /// This method adds a priority message to the instance
        /// </summary>
        /// <param name="message"></param>
        /// <param name="dataObjects"></param>
        /// <returns></returns>
        public Guid WithPriorityMessage(string message, params dynamic[] dataObjects) =>
            WithPriorityMessage(message, dataObjects);
    }
}
